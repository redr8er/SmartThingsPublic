/*
 * -----------------------
 * --- DEVICE HANDLER ----
 * -----------------------
 *
 * STOP:  Do NOT PUBLISH the code to GitHub, it is a VIOLATION of the license terms.
 * You are NOT allowed share, distribute, reuse or publicly host (e.g. GITHUB) the licensed code modifications. Refer to the license details on our website.
 *
 */

/* **DISCLAIMER**
* THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
* HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
* Without limitation of the foregoing, Contributors/Regents expressly does not warrant that:
* 1. the software will meet your requirements or expectations;
* 2. the software or the software content will be free of bugs, errors, viruses or other defects;
* 3. any results, output, or data provided through or generated by the software will be accurate, up-to-date, complete or reliable;
* 4. the software will be compatible with third party software;
* 5. any errors in the software will be corrected.
* The user assumes all responsibility for selecting the software and for the results obtained from the use of the software. The user shall bear the entire risk as to the quality and the performance of the software.
*
*/ 

def clientVersion() {
    return "01.08.01"
}

/*
 *
 * Enhanced Keypad Lock Device Handler
 *
 * Copyright RBoy Apps, redistribution or reuse of any changes is not allowed without permission
 *
 * Works with Centralite, XFinity, UEI and IRIS keypads which can be used as a lock device in SmartThings and compatible with SmartLocks
 *
 * Change log
 * 2019-05-20 - (v01.08.01) Report number if buttons for supported keypads with panic buttons
 * 2019-05-09 - (v01.08.00) Fix for platform changes to work with SHM Delay and Keypad Coordinator
 * 2019-05-07 - (v01.07.01) Temporary fix for changes in platform causing legacy event required by SHM Delay to cause all apps to stop working
 * 2019-04-26 - (v01.07.00) Added support for built in Siren/Alarm for IRIS v2 (3405-L)
 * 2019-04-02 - (v01.06.02) Fixed an issue wtih exit delay beeping with some keypads
 * 2019-03-04 - (v01.06.01) Show the invalid keycode entered (when available) in the event history
 * 2018-12-21 - (v01.06.00) Added support for the Centralite Retail Smart Keypad (3400-C)
 * 2018-12-20 - (v01.05.08) Respond to connection status query for devices like the IL02_1 which otherwise lose status/connection, turn off alarm state when disarmed using unlock code
 * 2018-12-17 - (v01.05.05) Turn off panic status after 1 minute, turn off alarm when disarming the keypad and fix accidental turn off off alarm when refreshing
 * 2018-11-30 - (v01.05.04) Update for supporting legacy apps, report code a 0000 for IRIS v3 and don't change mode if lock codes aren't used
 * 2018-11-27 - (v01.05.03) Update keypad mode when lock/unlock state changes (required for iL02_1 and IRIS keypads)
 * 2018-11-07 - (v01.05.02) Added support for Xfinity XHK1-TC
 * 2018-11-06 - (v01.05.01) Tweaked beeping for IRIS iL02_1 and XHK1/UEI keypads
 * 2018-11-05 - (v01.05.00) Added support for IRIS iL02_1 Keypad (v3)
 * 2018-11-01 - (v01.04.00) Updates to support ArnB SHM Delay 2.0 app
 * 2018-10-02 - (v01.03.01) Added support for UEI AA battery types (Lithium, Rechargeable, Alkaline), optimized single beep for UEI keypads
 * 2018-09-06 - (v01.02.03) Report DH version more often for better updates
 * 2018-08-16 - (v01.02.02) Check if device is offline once every 6 hours
 * 2018-08-02 - (v01.02.01) Added basic support for new ST app
 * 2018-07-28 - (v01.02.00) Update DTH to support new SmartLocks delayed event history and intialize lockCodes if null
 * 2018-07-24 - (v01.01.02) Don't limit size of code in updateCodes() and fix for deleteCode() when codename doesn't exist
 * 2018-05-01 - (v01.01.00) Added support for UEI keypads and updated DTH to be compliant with latest ST specs
 * 2018-04-21 - (v01.00.01) Allow for negative temperature bias
 * 2018-04-12 - (v01.00.00) Initial release with bug fixes and enhancements and lock capabilities
 *
 * Original keypad ZigBee code from Mitch Pond and Zack Cornelius
 *
 *  Copyright 2015-2016 Mitch Pond, Zack Cornelius
 *
 *  Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except
 *  in compliance with the License. You may obtain a copy of the License at:
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software distributed under the License is distributed
 *  on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License
 *  for the specific language governing permissions and limitations under the License.
 */

metadata {
	definition (name: "Enhanced ZigBee Keypad Lock", namespace: "rboy", author: "RBoy Apps", mnmn: "SmartThings", vid:"generic-lock") {
        capability "Lock"
        capability "Polling"
        capability "Refresh"
        capability "Sensor"
        capability "Lock Codes"
        capability "Battery"
        capability "Health Check"
        capability "Configuration"
        capability "Tamper Alert"
        capability "Motion Sensor"
		capability "Temperature Measurement"
		capability "Tone"
		capability "Button"
        capability "Alarm"
		
		attribute "armMode", "String"
        attribute "lastUpdate", "String"
        attribute "codeunlock", "string"
        attribute "autolock", "string"
        attribute "invalidCode", "string"
        attribute "codeVersion", "string"
        attribute "dhName", "string"
		
		command "setDisarmed"
		command "setArmedAway"
		command "setArmedStay"
		command "setArmedNight"
		command "setExitDelay", ['number']
		command "setEntryDelay", ['number']
		command "testCmd"
		command "sendInvalidKeycodeResponse"
		command "acknowledgeArmRequest"
        command "clearPanic"
        command "disableKeypad"
        command "enableKeypad"
        command "enableAutolock"
        command "disableAutolock"
        command "disableInvalidPinLogging", ['boolean']
		
		fingerprint endpointId: "01", profileId: "0104", deviceId: "0401", inClusters: "0000,0001,0003,0020,0402,0500,0B05", outClusters: "0019,0501", manufacturer: "CentraLite", model: "3400", deviceJoinName: "Xfinity 3400-X Keypad" // 01 0104 0401 00 07 0000 0001 0003 0020 0402 0500 0B05 02 0019 0501
		fingerprint endpointId: "01", profileId: "0104", deviceId: "0401", inClusters: "0000,0001,0003,0020,0402,0500,0B05", outClusters: "0019,0501", manufacturer: "CentraLite", model: "3400-G", deviceJoinName: "Centralite 3400-C Keypad" // 01 0104 0401 00 07 0000 0001 0003 0020 0402 0500 0B05 02 0019 0501
		fingerprint endpointId: "01", profileId: "0104", deviceId: "0401", inClusters: "0000,0001,0003,0020,0402,0500,0501,0B05,FC04", outClusters: "0019,0501", manufacturer: "CentraLite", model: "3405-L", deviceJoinName: "Iris 3405-L Keypad" // 01 0104 0401 00 09 0000 0001 0003 0020 0402 0500 0501 0B05 FC04 02 0019 0501
		fingerprint endpointId: "01", profileId: "0104", deviceId: "0401", inClusters: "0000,0001,0003,0020,0402,0500,0B05", outClusters: "0003,0019,0501", manufacturer: "Universal Electronics Inc", model: "URC4450BC0-X-R", deviceJoinName: "Xfinity XHK1-UE Keypad" // 01 0104 0401 00 07 0000 0001 0003 0020 0402 0500 0B05 03 0003 0019 0501
		fingerprint endpointId: "01", profileId: "0104", deviceId: "0401", inClusters: "0000,0001,0003,0020,0402,0500,0B05", outClusters: "0003,0019,0501,0B05", manufacturer: "Technicolor", model: "TKA105", deviceJoinName: "Xfinity XHK1-TC Keypad" // 01 0104 0401 00 07 0000 0001 0003 0020 0402 0500 0805 04 0003 0019 0501 OB05
		fingerprint endpointId: "01", profileId: "0104", deviceId: "0402", inClusters: "0000,0001,0003,0020,0402,0405,0500,0501,0B05,FC01,FC02", outClusters: "0003,0019,0501", manufacturer: "iMagic by GreatStar", model: "1112-S", deviceJoinName: "Iris iL02_1 Keypad" // 01 0104 0402 00 0B 0000 0001 0003 0020 0402 0405 0500 0501 0B05 FC01 FC02 03 0003 0019 0501
	}
	
    tiles (scale: 2) {
        multiAttributeTile(name: "keypad", type:"generic", width:6, height:4) {
            tileAttribute ("device.armMode", key: "PRIMARY_CONTROL") {            		
                attributeState "disarmed", label:'', icon:"http://www.rboyapps.com/images/Disarmed.png", backgroundColor:"#ffffff", defaultState: true
                attributeState "armedStay", label:'', icon:"http://www.rboyapps.com/images/ArmedStay.png", backgroundColor:"#ffffff"
                attributeState "armedAway", label:'', icon:"http://www.rboyapps.com/images/ArmedAway.png", backgroundColor:"#ffffff"
                attributeState "armedNight", label:'', icon:"http://www.rboyapps.com/images/ArmedStay.png", backgroundColor:"#ffffff"
            }
			tileAttribute("device.battery", key: "SECONDARY_CONTROL") {
				attributeState("default", label:'Battery: ${currentValue}%', unit:"%")
			}
        }
		standardTile("mode", "device.armMode", decoration: "flat", width: 2, height: 2) {
            state "disarmed", label:'', icon:"http://www.rboyapps.com/images/Disarmed.png", backgroundColor:"#ffffff", defaultState: true
            state "armedStay", label:'', icon:"http://www.rboyapps.com/images/ArmedStay.png", backgroundColor:"#ffffff"
            state "armedAway", label:'', icon:"http://www.rboyapps.com/images/ArmedAway.png", backgroundColor:"#ffffff"
            state "armedNight", label:'', icon:"http://www.rboyapps.com/images/ArmedStay.png", backgroundColor:"#ffffff"
        }
        standardTile("lock", "device.lock", inactiveLabel: false, decoration: "flat", width: 2, height: 2) {
            state "locked", label:'locked', action:"lock.unlock", icon:"st.locks.lock.locked", backgroundColor:"#00a0dc", nextState:"unlocking"
            state "unlocked", label:'unlocked', action:"lock.lock", icon:"st.locks.lock.unlocked", backgroundColor:"#ffffff", nextState:"locking"
            state "unknown", label:"unknown", action:"lock.lock", icon:"st.locks.lock.unknown", backgroundColor:"#e86d13", nextState:"locking", defaultState: true
            state "locking", label:'locking', icon:"st.locks.lock.locked", backgroundColor:"#00a0dc"
            state "unlocking", label:'unlocking', icon:"st.locks.lock.unlocked", backgroundColor:"#ffffff"
		}
		valueTile("temperature", "device.temperature", width: 2, height: 2) {
			state("temperature", label:'${currentValue}°',
                  backgroundColors:[
                      // Celsius
                      [value: 0, color: "#153591"],
                      [value: 7, color: "#1e9cbb"],
                      [value: 15, color: "#90d2a7"],
                      [value: 23, color: "#44b621"],
                      [value: 28, color: "#f1d801"],
                      [value: 35, color: "#d04e00"],
                      [value: 37, color: "#bc2323"],
                      // Fahrenheit
                      [value: 40, color: "#153591"],
                      [value: 44, color: "#1e9cbb"],
                      [value: 59, color: "#90d2a7"],
                      [value: 74, color: "#44b621"],
                      [value: 84, color: "#f1d801"],
                      [value: 95, color: "#d04e00"],
                      [value: 96, color: "#bc2323"]
                  ]
			)
		}
		valueTile("battery", "device.battery", width: 2, height: 2, inactiveLabel: false) {
            state "battery", label:'${currentValue}%', unit: "", icon: "http://smartthings.rboyapps.com/images/battery.png", backgroundColors:[
                [value: 15, color: "#ff0000"],
                [value: 30, color: "#fd4e3a"],
                [value: 50, color: "#fda63a"],
                [value: 60, color: "#fdeb3a"],
                [value: 75, color: "#d4fd3a"],
                [value: 90, color: "#7cfd3a"],
                [value: 99, color: "#55fd3a"]
            ]
        }
        standardTile("motion", "device.motion", width: 2, height: 2, inactiveLabel: false, decoration: "flat") {
            state "active", label:'motion', icon:"st.motion.motion.active", backgroundColor:"#00a0dc"
            state "inactive", label:'no motion', icon:"st.motion.motion.inactive", backgroundColor:"#ffffff", defaultState: true
        }
		standardTile("tamper", "device.tamper", width: 2, height: 2, inactiveLabel: false, decoration: "flat") {
			state "clear", label:'', backgroundColor:"#FFFFFF", defaultState: true
			state "detected", label:'TAMPER', backgroundColor:"#e86d13"
		}
        standardTile("panic", "device.button", decoration: "flat", width: 2, height: 2) {
            state "", label: '', icon:"", backgroundColor: "#ffffff", defaultState: true
            state "pushed", label: 'Panic', icon:"st.security.alarm.alarm", backgroundColor:"#e86d13", action: "clearPanic"
        }
        standardTile("alarm", "device.alarm", decoration: "flat", width: 2, height: 2) {
            state "", label: '', icon: "", backgroundColor: "#ffffff", defaultState: true
            state "off", label: 'Alarm', icon: "st.alarm.alarm.alarm", backgroundColor: "#ffffff", action: "alarm.both"
            state "both", label: 'Alarm', icon:"st.security.alarm.alarm", backgroundColor:"#e86d13", action: "alarm.off"
            state "siren", label: 'Alarm', icon:"st.security.alarm.alarm", backgroundColor:"#e86d13", action: "alarm.off"
            state "strobe", label: 'Alarm', icon:"st.security.alarm.alarm", backgroundColor:"#e86d13", action: "alarm.off"
        }
        standardTile("beep", "device.beep", decoration: "flat", width: 2, height: 2) {
            state "default", label: "Locate/beep", action:"tone.beep", icon:"st.quirky.spotter.quirky-spotter-sound-on", backgroundColor:"#ffffff"
        }
        standardTile("refresh", "device.refresh", inactiveLabel: false, decoration: "flat", width: 2, height: 2) {
            state "default", action:"refresh.refresh", icon:"st.secondary.refresh"
        }
        standardTile("configure", "device.configure", inactiveLabel: false, decoration: "flat", width: 2, height: 2) {
            state "default", action:"configuration.configure", icon:"st.secondary.configure"
        }
        valueTile("armMode", "device.armMode", decoration: "flat", width: 2, height: 2) {
            state "armMode", label: '${currentValue}'
        }
        standardTile("codeunlock", "device.codeunlock", inactiveLabel: false, decoration: "flat", width: 2, height: 2) {
            state "unknown", label:'', icon:"", backgroundColor:"#ffffff", nextState:"working", defaultState: true
            state "enabled", label:'Code Entry On', action:"disableKeypad", icon:"st.unknown.zwave.remote-controller", backgroundColor:"#ffffff", nextState:"working"
            state "disabled", label:'Code Off', action:"enableKeypad", icon:"st.unknown.zwave.remote-controller", backgroundColor:"#00a0dc", nextState:"working"
            state "working", label:'...', icon:"st.unknown.zwave.remote-controller", backgroundColor:"#cccccc"
        }
        standardTile("autolock", "device.autolock", inactiveLabel: false, decoration: "flat", width: 2, height: 2) {
            state "unknown", label:'', icon:"", backgroundColor:"#ffffff", nextState:"working", defaultState: true
            state "enabled", label:'AutoLock', action:"disableAutolock", icon:"st.contact.contact.closed", backgroundColor:"#00a0dc", nextState:"working"
            state "disabled", label:'AutoLock Off', action:"enableAutolock", icon:"st.contact.contact.closed", nextState:"working"
            state "working", label:'...', icon:"st.contact.contact.closed", backgroundColor:"#cccccc"
        }
        valueTile("blank2x", "device.refresh", decoration: "flat", width: 2, height: 2) {
            state "", label: ''
        }

        main (["lock"])
        details (["mode", "lock", "autolock", "motion", "codeunlock", "beep", "temperature", "battery", "refresh", "tamper", "panic", "alarm"])
    }
}

preferences {
    section() {
        input title: "", description: "Enhanced ZigBee Keypad Lock Device Handler v${clientVersion()}", type: "paragraph", element: "paragraph", displayDuringSetup: true
        input "autoLockTimeout", "number", title: "Auto lock delay (seconds)", defaultValue: defaultAutoLockTime, range: "1..*", required: true, displayDuringSetup: false
        input "tempOffset", "number", title: "Temperature correction offset", defaultValue: defaultTempOffset, range: "*..*", displayDuringSetup: false
        input "beepLength", "number", title: "No of beeps", defaultValue: defaultBeepLength, range: "1..*", displayDuringSetup: false
        input "motionTimeout", "number", title: "Motion inactivity timeout (seconds)", defaultValue: defaultInactivityTimeout, displayDuringSetup: false
    }
    
    section() {
        input title: "", description: "", type: "paragraph", element: "paragraph", displayDuringSetup: true
        input title: "", description: "IL021/UEI/XHK1 Keypad Options", type: "paragraph", element: "paragraph", displayDuringSetup: true
        input "ueiBattery", "enum", title: "Battery Type", options: ["Lithium", "Alkaline", "Rechargeable"], defaultValue: "Lithium", displayDuringSetup: true
    }
}


// GLOBAL DEFAULTS
private getMaxUsers() { 999 } // Maximum number of user codes supported
private getDefaultBeepLength() { 1 } // Default number of beeps
private getDefaultInactivityTimeout() { 10 } // Default motion inactive timeout
private getDefaultTempOffset() { 0 } // Default temperature offset
private getDefaultAutoLockTime() { 30 } // Default autolock timeout
private getPANIC_RESET_TIMEOUT() { 60 } // Timeout in seconds to reset panic state (not alarm)
private getPANEL_STATUS_ALARMED() { 7 }
private getPANEL_STATUS_DISARMED() { 0 }
private getPANEL_STATUS_ENTRY_DELAY() { 5 }
private getPANEL_STATUS_EXIT_DELAY() { 10 }

/**
* Called on app installed
*/
def installed() {
    state.userCodes = [:]
    
    // Device-Watch pings if no device events received for 6 hour (checkInterval)
    sendEvent(name: "checkInterval", value: 6 * 60 * 60, displayed: false, data: [protocol: "zigbee", hubHardwareId: device.hub.hardwareID, offlinePingable: "1"])
    sendEvent(name: "codeunlock", value: "enabled", descriptionText: "Keypad") // Initialize default
    sendEvent(name: "autolock", value: "disabled", descriptionText: "Auto lock") // Initialize default
    sendEvent(name: "lockCodes", value: util.toJson([:]), displayed: false, descriptionText: "'lockCodes' attribute updated")
    getCodeLength() // Initialize it
}

/**
* Called on app uninstalled
*/
def uninstalled() {
    def deviceName = device.displayName
    log.trace "[DTH] Executing 'uninstalled()' for device $deviceName"
    sendEvent(name: "lockRemoved", value: device.id, isStateChange: true, displayed: false)
}

/**
* Executed when the user taps on the 'Done' button on the device settings screen. Sends the values to lock.
*/
def updated() {
    log.trace "Updated called settings: $settings"
    // Device-Watch pings if no device events received for 6 hour (checkInterval)
    sendEvent(name: "checkInterval", value: 6 * 60 * 60, displayed: false, data: [protocol: "zigbee", hubHardwareId: device.hub.hardwareID, offlinePingable: "1"])
    refresh()
}

// API COMMANDS
def enableKeypad() {
    log.debug "Enabling keypad"
    sendEvent(name: "codeunlock", value: "enabled", descriptionText: "Keypad enabled")
}

def disableKeypad() {
    log.debug "Disabling keypad"
    sendEvent(name: "codeunlock", value: "disabled", descriptionText: "Keypad disabled")
}

def enableAutolock() {
    log.debug "Enabling autolock with timeout ${autoLockTimeout ?: defaultAutoLockTime} seconds"
    sendEvent(name: "autolock", value: "enabled", descriptionText: "Auto lock")
}

def disableAutolock() {
    log.debug "Disabling autolock"
    sendEvent(name: "autolock", value: "disabled", descriptionText: "Auto lock")
}

/**
 * Executes lock command on a lock
 */
def lock(data = null) {
	log.trace "[DTH] Executing lock() for device ${device.displayName}${data?.method ? " with extended data ${data.inspect()}" : ""}"
	def map = [ name: "lock", value: "locked", descriptionText: "Locked" ]
    if (data?.method) {
        map.data = [ method: data?.method ]
    }
    sendEvent(map)
    if (device.currentValue("armMode") == "disarmed") { // If it's arleady in armed state then keep it
        sendHubCommand(setModeHelper("armedAway", 0)) // TODO: How can we handle this better since ther are 3 armed modes for some keypads, what's the default for lock?
    }
}

/**
 * Executes unlock command on a lock
 */
def unlock() {
	log.trace "[DTH] Executing unlock() for device ${device.displayName}"
	sendEvent(name: "lock", value: "unlocked", descriptionText: "Unlocked")
    autoRelock()
    if (device.currentValue("armMode") != "disarmed") { // If it's arleady in disarmed state then keep it
        sendHubCommand(setModeHelper("disarmed", 0))
    }
}

private autoRelock() {
    if (device.currentValue("autolock") == "enabled") {
        def time = autoLockTimeout ?: defaultAutoLockTime
        log.trace "Auto lock enabled, locking in $time seconds"
        runIn(time, lock, [data: [method: "auto"]]) // relock
    }
}

/**
 * PING is used by Device-Watch in attempt to reach the Device
 */
def ping() {
	log.trace "[DTH] Executing ping() for device ${device.displayName}"
	refresh()
}

/**
 * Returns the command for user code get
 *
 * @param codeID: The code slot number
 *
 * @return null
 */
def requestCode(codeID) {
	return null
}

/**
 * API endpoint for server smart app to populate the attributes. Called only when the attributes are not populated.
 *
 * @return null
 */
def reloadAllCodes() {
	log.trace "[DTH] Executing 'reloadAllCodes()' by ${device.displayName}"
    
    return null
}

/**
 * API endpoint for setting the user code length on a lock. This is specific to Schlage locks.
 *
 * @param length: The user code length
 *
 * @returns null
 */
def setCodeLength(length) {
    log.debug "SetCodeLength(): Keypad only supports 4 digit code lengths"

    return null
}

/**
 * API endpoint for getting the user code length on a lock.
 *
 * @returns null
 */
def getCodeLength() {
    log.debug "GetCodeLength(): Supports 4 digit code length"
    sendEvent(name: "codeLength", value: 4, descriptionText: "Pin code length") // Fixed length 4 digits for these keypads
    return null
}

// Reports that code was processed successfully
def reportCodeProcessed() {
    def result = state.pending
    log.trace "Sending code reports: ${result}"
    result?.each { sendEvent(it) }
    state.pending = [] // Clear it after we successfully send all events
}

/**
 * API endpoint for setting a user code on a lock
 *
 * @param codeID: The code slot number
 *
 * @param code: The code PIN
 *
 * @param codeName: The name of the code
 *
 * @returns null
 */
def setCode(codeID, code, codeName = null) {
	if (!code) {
		log.trace "[DTH] Executing 'nameSlot()' by ${this.device.displayName}"
		nameSlot(codeID, codeName)
		return
	}

    def result = setCodeGenerate(codeID, code, codeName)
    state.pending = ((state.pending ?: []) + result).flatten() // Save the list for processing since we may get multiple repeat calls
    runIn(1, reportCodeProcessed) // Delay sending the report as SmartLocks looks at timestamp and it should happen after the method ends

    return null
}

// Internal function to return the events required to confirm setting a code
private setCodeGenerate(codeID, code, codeName = null) {
	log.trace "[DTH] Executing 'setCode()' for slot $codeID, name $codeName by ${this.device.displayName}"

	def strname = (codeName ?: "Code $codeID")
	state["setname$codeID"] = strname
	
	validateAttributes()

	def result = []
	def map = null
	def changeType, lockCodes
	def deviceName = device.displayName

    state.userCodes["$codeID"] = code // Save the code for lookup

    lockCodes = loadLockCodes()
    changeType = getChangeType(lockCodes, codeID)
    map = [ name: "codeChanged", value: "$codeID $changeType",  descriptionText: "${getStatusForDescription(changeType)} \"$codeName\"", isStateChange: true ]
    map.data = [ codeName: codeName, notify: true, notificationText: "${getStatusForDescription(changeType)} \"$codeName\" in $deviceName at ${location.name}" ]
    if(!isMasterCode(codeID)) {
        result << codeSetEvent(lockCodes, codeID, codeName)
    } else {
        map.descriptionText = "${getStatusForDescription('set')} \"$codeName\""
        map.data.notificationText = "${getStatusForDescription('set')} \"$codeName\" in $deviceName at ${location.name}"
    }

    if (map.data) {
        map.data.lockName = deviceName
    } else {
        map.data = [ lockName: deviceName ]
    }
    result << createEvent(map)
    result = result.flatten()
    
    result
}

/**
 * Validates attributes
 */
def validateAttributes() {
	if(!device.currentValue("maxCodes")) {
        sendEvent(name: "maxCodes", value: maxUsers, displayed: false)
        state.codes = maxUsers
        state.remove("checkCode")
        state["checkCode"] = null
	}
    
	return null
}

/**
 * API endpoint for setting/deleting multiple user codes on a lock
 *
 * @param codeSettings: The map with code slot numbers and code pins (in case of update)
 *
 * @returns The commands fired for creation and deletion of lock codes
 */
def updateCodes(codeSettings) {
	log.trace "[DTH] Executing updateCodes() for device ${device.displayName}"
	if(codeSettings instanceof String) codeSettings = util.parseJson(codeSettings)

    def result = []
    codeSettings.each { name, updated ->
		if (name.startsWith("code")) {
			def n = name[4..-1].toInteger()
			if (updated) { // Don't check code size here, leave it to the SmartApp as different locks have different limitations
				log.debug "Setting code number $n"
                result << setCodeGenerate(n, updated)
			} else if (updated == null || updated == "" || updated == "0") {
				log.debug "Deleting code number $n"
                result << deleteCodeGenerate(n)
			}
		} else log.warn("unexpected entry $name: $updated")
	}

    result = result.flatten()
    state.pending = ((state.pending ?: []) + result).flatten() // Save the list for processing since we may get multiple repeat calls
    runIn(1, reportCodeProcessed) // Delay sending the report as SmartLocks looks at timestamp and it should happen after the method ends

    return null
}

/**
 * Renames an existing lock slot
 *
 * @param codeSlot: The code slot number
 *
 * @param codeName The new name of the code
 */
void nameSlot(codeSlot, codeName) {
	codeSlot = codeSlot.toString()
	if (!isCodeSet(codeSlot)) {
		return
	}
	def deviceName = device.displayName
	log.trace "[DTH] - Executing nameSlot() for slot $codeSlot, name $codeName for device $deviceName"
	def lockCodes = loadLockCodes()
	def oldCodeName = getCodeName(lockCodes, codeSlot)
	def newCodeName = codeName ?: "Code $codeSlot"
	lockCodes[codeSlot] = newCodeName
	sendEvent(lockCodesEvent(lockCodes))
	sendEvent(name: "codeChanged", value: "$codeSlot renamed", data: [ lockName: deviceName, notify: false, notificationText: "Renamed \"$oldCodeName\" to \"$newCodeName\" in $deviceName at ${location.name}" ],
		descriptionText: "Renamed \"$oldCodeName\" to \"$newCodeName\"", displayed: true, isStateChange: true)
}

/**
 * API endpoint for deleting a user code on a lock
 *
 * @param codeID: The code slot number
 *
 * @returns cmds: The command fired for deletion of a lock code
 */
def deleteCode(codeID) {
    def result = deleteCodeGenerate(codeID)
    state.pending = ((state.pending ?: []) + result).flatten() // Save the list for processing since we may get multiple repeat calls
    runIn(1, reportCodeProcessed) // Delay sending the report as SmartLocks looks at timestamp and it should happen after the method ends

    return null
}

// Internal function to return the events required to confirm deleting a code
private def deleteCodeGenerate(codeID) {
	log.trace "[DTH] Executing 'deleteCode()' for slot $codeID by ${this.device.displayName}"

    state.userCodes["$codeID"] = null // Delete the code from lookup (remove doesn't work on state)
    
	def result = []
	def map = [ name: "codeChanged", isStateChange: true ]
	def changeType, lockCodes, codeName
	def deviceName = device.displayName
	lockCodes = loadLockCodes()
    if (lockCodes[codeID.toString()]) {
        codeName = getCodeName(lockCodes, codeID)
        map.value = "$codeID deleted"
        map.descriptionText = "Deleted \"$codeName\""
        map.data = [ codeName: codeName, lockName: deviceName, notify: true, notificationText: "Deleted \"$codeName\" in $deviceName at ${location.name}" ]
        result << codeDeletedEvent(lockCodes, codeID)
    } else {
        map.value = "$codeID unset"
        map.displayed = false
        map.data = [ lockName: deviceName ]
    }

    result << createEvent(map)
    result = result.flatten()
    
    result
}

/**
 * Reads the code name from the 'lockCodes' map
 *
 * @param lockCodes: map with lock code names
 *
 * @param codeID: The code slot number
 *
 * @returns The code name
 */
private String getCodeName(lockCodes, codeID) {
	if (isMasterCode(codeID)) {
		return "Master Code"
	}
	lockCodes[codeID.toString()] ?: "Code $codeID"
}

/**
 * Reads the code name from the device state
 *
 * @param lockCodes: map with lock code names
 *
 * @param codeID: The code slot number
 *
 * @returns The code name
 */
private String getCodeNameFromState(lockCodes, codeID) {
	if (isMasterCode(codeID)) {
		return "Master Code"
	}
	def nameFromLockCodes = lockCodes[codeID.toString()]
	def nameFromState = state["setname$codeID"]
	if(nameFromLockCodes) {
		if(nameFromState) {
			//Updated from smart app
			return nameFromState
		} else {
			//Updated from lock
			return nameFromLockCodes
		}
	} else if(nameFromState) {
		//Set from smart app
		return nameFromState
	}
	//Set from lock
	return "Code $codeID"
}

/**
 * Check if a user code is present in the 'lockCodes' map
 *
 * @param codeID: The code slot number
 *
 * @returns true if code is present, else false
 */
private Boolean isCodeSet(codeID) {
	// BUG: Needed to add loadLockCodes to resolve null pointer when using schlage?
	def lockCodes = loadLockCodes()
	lockCodes[codeID.toString()] ? true : false
}

/**
 * Reads the 'lockCodes' attribute and parses the same
 *
 * @returns Map: The lockCodes map
 */
private Map loadLockCodes() {
	parseJson(device.currentValue("lockCodes") ?: "{}") ?: [:]
}

/**
 * Populates the 'lockCodes' attribute by calling create event
 *
 * @param lockCodes The user codes in a lock
 */
private Map lockCodesEvent(lockCodes) {
	createEvent(name: "lockCodes", value: util.toJson(lockCodes), displayed: false,
	descriptionText: "'lockCodes' attribute updated")
}

/**
 * Utility function to figure out if code id pertains to master code or not
 *
 * @param codeID - The slot number in which code is set
 * @return - true if slot is for master code, false otherwise
 */
private boolean isMasterCode(codeID) {
	if(codeID instanceof String) {
		codeID = codeID.toInteger()
	}
	(codeID == 0) ? true : false
}

/**
 * Creates the event map for user code creation
 *
 * @param lockCodes: The user codes in a lock
 *
 * @param codeID: The code slot number
 *
 * @param codeName: The name of the user code
 *
 * @return The list of events to be sent out
 */
private def codeSetEvent(lockCodes, codeID, codeName) {
	clearStateForSlot(codeID)
	// codeID seems to be an int primitive type
	lockCodes[codeID.toString()] = (codeName ?: "Code $codeID")
	def result = []
	result << lockCodesEvent(lockCodes)
	def codeReportMap = [ name: "codeReport", value: codeID, data: [ code: "" ], isStateChange: true, displayed: false ]
	codeReportMap.descriptionText = "${device.displayName} code $codeID is set"
	result << createEvent(codeReportMap)
	result
}

/**
 * Creates the event map for user code deletion
 *
 * @param lockCodes: The user codes in a lock
 *
 * @param codeID: The code slot number
 *
 * @return The list of events to be sent out
 */
private def codeDeletedEvent(lockCodes, codeID) {
	lockCodes.remove("$codeID".toString())
	// not sure if the trigger has done this or not
	clearStateForSlot(codeID)
	def result = []
	result << lockCodesEvent(lockCodes)
	def codeReportMap = [ name: "codeReport", value: codeID, data: [ code: "" ], isStateChange: true, displayed: false ]
	codeReportMap.descriptionText = "${device.displayName} code $codeID was deleted"
	result << createEvent(codeReportMap)
	result
}

/**
 * Creates the event map for all user code deletion
 *
 * @return The List of events to be sent out
 */
private def allCodesDeletedEvent() {
	def result = []
	def lockCodes = loadLockCodes()
	def deviceName = device.displayName
	lockCodes.each { id, code ->
		result << createEvent(name: "codeReport", value: id, data: [ code: "" ], descriptionText: "code $id was deleted",
					displayed: false, isStateChange: true)
		
		def codeName = code
		result << createEvent(name: "codeChanged", value: "$id deleted", data: [ codeName: codeName, lockName: deviceName,
			notify: true, notificationText: "Deleted \"$codeName\" in $deviceName at ${location.name}" ],
		descriptionText: "Deleted \"$codeName\"",
		displayed: true, isStateChange: true)
		clearStateForSlot(id)
	}
	result
}

/**
 * Checks if a change type is set or update
 *
 * @param lockCodes: The user codes in a lock
 *
 * @param codeID The code slot number
 *
 * @return "set" or "update" basis the presence of the code id in the lockCodes map
 */
private def getChangeType(lockCodes, codeID) {
	def changeType = "set"
	if (lockCodes[codeID.toString()]) {
		changeType = "changed"
	}
	changeType
}

/**
 * Method to obtain status for descriptuion based on change type
 * @param changeType: Either "set" or "changed"
 * @return "Added" for "set", "Updated" for "changed", "" otherwise
 */
private def getStatusForDescription(changeType) {
	if("set" == changeType) {
		return "Added"
	} else if("changed" == changeType) {
		return "Updated"
	}
	//Don't return null as it cause trouble
	return ""
}

/**
 * Clears the code name and pin from the state basis the code slot number
 *
 * @param codeID: The code slot number
 */
def clearStateForSlot(codeID) {
	state.remove("setname$codeID")
	state["setname$codeID"] = null
}

/**
 * Find the corresponding slot for a code
 *
 * @param code: The code
 * @return codeID or null if not found
 */
private findUserID(code) {
    //log.trace "User Codes: ${state.userCodes?.inspect()}"
    def id = state.userCodes.find { key, value ->
        value == code ? true : false
    }
    
    return id?.key
}

// OTHER STUFF
// parse events into attributes
def parse(String description) {
	log.trace "Parsing: ${zigbee.parseDescriptionAsMap(description) ?: description}"
    
    sendEvent([name: "codeVersion", value: clientVersion()]) // Save client version for parent app
    sendEvent([name: "dhName", value: "Enhanced Keypad Lock Device Handler"]) // Save DH Name for parent app

    def results = []

    def event = zigbee.getEvent(description)
    if (event) {
        log.debug "Parsed zigbee event: $event"
        results = createEvent(event)
    } else {
        // Miscellaneous Zigbee message
        if (description?.startsWith('catchall:')) {
            def message = zigbee.parse(description)
            log.trace "Parsed: $message"

            // Profile-wide command (rattr responses, errors, etc
            if (message?.isClusterSpecific == false) {
                if (message?.command == 0x0B) { // Default response
                    if (message?.data[1] == 0x81) {
                        log.error "Device: unrecognized command: $description\n$message"
                    }  else if (message?.data[1] == 0x80)  {
                        log.error "Device: malformed command: $description\n$message"
                    }
                } else if (message?.command == 0x01) { // Read attributes responses
                    if (message?.clusterId == 0x0402) {
                        log.trace "Device: read attribute response"
                        results = parseTempAttributeMsg(message)
                    }
                } else {
                    log.warn "Unhandled profile-wide command: $message"
                }
            } else if (message?.isClusterSpecific) { // Cluster specific commands
                if (message?.clusterId == 0x0501) { // 8.3.2.4
                    if (message?.command == 0x07) { // Panel status
                        motionON()
                        if (device.currentValue("alarm") != "both") {
                            sendHubCommand(sendStatusToDevice(true)) // Respond to request we aren't in alarm mode otherwise it may turn off the alarm
                        }
                    } else if (message?.command == 0x04) { // Panic
                        log.debug "Panic button pushed"
                        both() // Turn on alarm if supported
                        results = createEvent(name: "button", value: "pushed", data: [buttonNumber: 1], descriptionText: "$device.displayName panic button was pushed", isStateChange: true)
                        runIn(PANIC_RESET_TIMEOUT, resetPanic)
                    } else if (message?.command == 0x00) { // Arm
                        results = handleCodeInputs(message) // Process user code entry
                    }
                } else {
                    log.warn "Unhandled cluster-specific command: $message"
                }
            }
        } else if (description?.startsWith('enroll request')) { // IAS Zone Enroll request
            log.trace "Sending IAS enroll response"
            //results = zigbee.enrollResponse()
            results = zigbee.iasZoneConfig() // Does an enrollResponse() + Configure reporting for IAS Zone Cluster
        } else if (description?.startsWith('read attr -')) { // Read Attribute response
            results = parseReportAttributeMessage(description)
        } else if (description?.startsWith('temperature: ')) { // Temperature Report
            log.trace "Got ST-style temperature report"
            results = createEvent(getTemperatureResult(zigbee.parseHATemperatureValue(description, "temperature: ", getTemperatureScale())))
        } else if (description?.startsWith('zone status ')) {
            log.trace "Processing zone status"
            results = parseIasMessage(description)
        }
    }
    
    results ? log.trace(results) : ""
    
	return results
}


def configure() {
    log.debug "Configure Called"
    
    String hubZigbeeId = swapEndianHex(device.hub.zigbeeEui)
    def cmds = [
        //------IAS Zone/CIE setup------//
        "zcl global write 0x500 0x10 0xf0 {${hubZigbeeId}}", "delay 100",
        "send 0x${device.deviceNetworkId} ${device.endpointId as int} 1", "delay 200",

        //------Set up binding------//
        "zdo bind 0x${device.deviceNetworkId} 1 1 0x500 {${device.zigbeeId}} {}", "delay 200",
        "zdo bind 0x${device.deviceNetworkId} 1 1 0x501 {${device.zigbeeId}} {}", "delay 200",
        
    ] + 
    zigbee.batteryConfig(3600, 43200, 0x01) +
    zigbee.temperatureConfig(30, 3600, 0x0064)

    runIn(15, refresh) // Give the configuration time to finish up and then do a refresh
    
    return cmds
}

def poll() { 
    log.debug "Poll called"

	refresh()
}

def refresh() {
    log.trace "Refresh called"
    
    sendEvent([name: "codeVersion", value: clientVersion()]) // Save client version for parent app
    sendEvent([name: "dhName", value: "Enhanced Keypad Lock Device Handler"]) // Save DH Name for parent app

    if (!state.userCodes) {
        state.userCodes = [:] // Initialize it
    }
    if(device.currentValue("lockCodes") == null) { // Initialize it
        sendEvent(name: "lockCodes", value: util.toJson([:]), displayed: false, descriptionText: "'lockCodes' attribute updated")
    }
    if(!device.currentValue("codeunlock")) {
        sendEvent(name: "codeunlock", value: "enabled", descriptionText: "Initializing keypad") // Initialize default
    }
    if(!device.currentValue("autolock")) {
        sendEvent(name: "autolock", value: "disabled", descriptionText: "Initializing auto lock") // Initialize default
    }
    if(!device.currentValue("lock")) {
        sendEvent(name: "lock", value: "unlocked", descriptionText: "Initializing lock") // Initialize default
    }
    if(!device.currentValue("armMode")) {
        sendEvent(name: "armMode", value: "disarmed", descriptionText: "Initializing keypad to disarm") // Initialize default
    }
    if(!device.currentValue("motion")) {
        sendEvent(name: "motion", value: "inactive", descriptionText: "Initializing motion") // Initialize default
    }
    if(!device.currentValue("numberOfButtons")) {
        if (["1112-S", "3405-L", "3400-G"].any { getDataValue("model") == it }) { // Initialize alarm if supported
            sendEvent(name: "numberOfButtons", value: 1, descriptionText: "Reporting 1 panic button") // Initialize default
        }
    }
    if (["1112-S", "3405-L"].any { getDataValue("model") == it }) { // Initialize alarm if supported
        if (!device.currentValue("alarm")) { // Check if it's been initialized
            log.info "Activating alarm feature for supported device"
            sendEvent(name: "alarm", value: "off", descriptionText: "Initializing alarm")
        }
    } else {
        sendEvent(name: "alarm", value: "", displayed: false) // Reset it if the keypad changed
    }
    
    if (!device.currentValue("codeLength")) { // Check if it's initialized
        getCodeLength() // Pin code length
    }

    validateAttributes()

    def cmds = []
    if (device.currentValue("alarm") != "both") { // Don't update status if we are in alarmed state since it may disarm it
        cmds += sendStatusToDevice()
    }
    cmds += zigbee.readAttribute(zigbee.POWER_CONFIGURATION_CLUSTER, 0x20) + // Battery
        zigbee.readAttribute(zigbee.TEMPERATURE_MEASUREMENT_CLUSTER, 0x00) // Temperature

    sendHubCommand(cmds, 100)
    
    return null
}

private formatLocalTime(time, format = "EEE, MMM d yyyy @ h:mm:ss a z") {
	if (time instanceof Long) {
    	time = new Date(time)
    }
	if (time instanceof String) {
    	//get UTC time
    	time = timeToday(time, location.timeZone)
    }   
    if (!(time instanceof Date)) {
    	return null
    }
	def formatter = new java.text.SimpleDateFormat(format)
	formatter.setTimeZone(location.timeZone)
	return formatter.format(time)
}

private parseReportAttributeMessage(String description) {
	Map descMap = (description - "read attr - ").split(",").inject([:]) { map, param ->
		def nameAndValue = param.split(":")
		map += [(nameAndValue[0].trim()):nameAndValue[1].trim()]
	}
	
    log.trace "Parsing attribute message: $descMap"

	def results = []
	
	if (descMap.cluster == "0001" && descMap.attrId == "0020") {
		log.debug "Received battery level report"
		results = createEvent(getBatteryResult(Integer.parseInt(descMap.value, 16)))
	} else if (descMap.cluster == "0001" && descMap.attrId == "0034") {
    	log.debug "Received Battery Rated Voltage: ${descMap.value}"
    } else if (descMap.cluster == "0001" && descMap.attrId == "0036") {
    	log.debug "Received Battery Alarm Voltage: ${descMap.value}"
    } else if (descMap.cluster == "0402" && descMap.attrId == "0000") {
		def value = getTemperature(descMap.value)
		results = createEvent(getTemperatureResult(value))
	}

	return results
}

private parseTempAttributeMsg(message) {
	byte[] temp = message.data[-2..-1].reverse()
	createEvent(getTemperatureResult(getTemperature(temp.encodeHex() as String)))
}

private Map parseIasMessage(String description) {
    List parsedMsg = description.split(' ')
    String msgCode = parsedMsg[2]
    
    Map resultMap = [:]
    switch(msgCode) {
        case '0x0020': // Closed/No Motion/Dry
        	resultMap = getContactResult('closed')
            break

        case '0x0021': // Open/Motion/Wet
        	resultMap = getContactResult('open')
            break

        case '0x0022': // Tamper Alarm
            break

        case '0x0023': // Battery Alarm
            break

        case '0x0024': // Supervision Report
        	resultMap = getContactResult('closed')
            break

        case '0x0025': // Restore Report
        	resultMap = getContactResult('open')
            break

        case '0x0026': // Trouble/Failure
            break

        case '0x0028': // Test Mode
            break
            
        case '0x0000':
			resultMap = createEvent(name: "tamper", value: "clear", isStateChange: true, displayed: true)
            break
            
        case '0x0004':
			resultMap = createEvent(name: "tamper", value: "detected", isStateChange: true, displayed: true)
            break
            
        default:
        	log.debug "Invalid message code in IAS message: ${msgCode}"
    }
    return resultMap
}


private Map getMotionResult(value) {
	String linkText = getLinkText(device)
	String descriptionText = value == 'active' ? "${linkText} detected motion" : "${linkText} motion has stopped"
	return [
		name: 'motion',
		value: value,
		descriptionText: descriptionText
	]
}
def motionON() {
    sendEvent(name: "motion", value: "active")
    
	// Calculate Inactive timeout value
	def motionTimeRun = (motionTimeout >= 0) ? motionTimeout : defaultInactivityTimeout

	// If Inactive timeout was configured
    log.debug "Motion Active, deactivating in $motionTimeRun seconds"
	if (motionTimeRun > 0) {
		runIn(motionTimeRun, "motionOFF", [overwrite: true]) // If something was pending, overwrite it
	} else {
        motionOFF()
    }
}

def motionOFF() {
	log.debug "Motion Inactive"
    sendEvent(name: "motion", value: "inactive")
}

def resetPanic() {
    log.trace "Resetting Panic state"
    sendEvent(name: "button", value: "", displayed: false) // No need to show reset
}

def clearPanic() {
    log.trace "Clearing Panic state"
    resetPanic()
    off() // Turn off alarm if supported
}

// Alarm commands
def strobe() { both() }
def siren() { both() }

// Turn on panic alarm on the device if supported
def both() {
    if (["1112-S", "3405-L"].any { getDataValue("model") == it }) {
        log.trace "Turning on alarm"
        sendHubCommand(sendRawStatus(PANEL_STATUS_ALARMED, 0, false, true))
        sendEvent(name: "alarm", value: "both")
        return null
    } else {
        log.trace "Device doesn't not support alarm feature"
    }
}

// Turn off panic alarm on the device if supported
def off() {
    if (["1112-S", "3405-L"].any { getDataValue("model") == it }) {
        log.trace "Turning off alarm"
        sendHubCommand(sendRawStatus(PANEL_STATUS_DISARMED) + sendStatusToDevice()) // Turn off Alarm and send latest arm status to device
        sendEvent(name: "alarm", value: "off")
        return null
    } else {
        log.trace "Device doesn't not support alarm feature"
    }
}

//Converts the battery level response into a percentage to display in ST
private getBatteryResult(rawValue) {
	def linkText = getLinkText(device)

	def result = [name: "battery"]

	def volts = ((double) rawValue) / 10
    log.trace "Total reported voltage (V): $volts"
    // Centralite / IRIS use CR123A (2 in parallel), UEI uses 4 x Lithium batteries in series
    def minVolts, maxVolts
    switch (getDataValue("manufacturer")) {
        case "iMagic by GreatStar":
        case "Technicolor":
        case "Universal Electronics Inc": // Uses about 1-3ma constant and 50ma to boot up
        	switch (ueiBattery) {
                case "Alkaline": // AA Alkaline, http://data.energizer.com/PDFs/lithiuml91l92_appman.pdf
                    minVolts = (0.8 * 4)
	                maxVolts = (1.55 * 4) 
                	break
                    
                case "Rechargeable": // AA NiMH, http://data.energizer.com/pdfs/nickelmetalhydride_appman.pdf, https://www.powerstream.com/AA-tests.htm#nimh
                    minVolts = (1.0 * 4)
	                maxVolts = (1.35 * 4) 
                	break

                case "Lithium": // AA Lithium 1.5v x 4 batteries = max battery level is 1.7v and dead battery level is 1.3v (http://data.energizer.com/PDFs/lithiuml91l92_appman.pdf), http://data.energizer.com/pdfs/l91.pdf
                default:
                    minVolts = (1.1 * 4)
	                maxVolts = (1.7 * 4) 
                	break
            }
        	break
            
        default: // CR123 Alkaline batteries, http://www.batteryspace.com/prod-specs/cr123A_1300.pdf
            minVolts = 2.0
            maxVolts = 3.2
            break
    }
    
    def pct = (Math.max(0, volts - minVolts)) / (maxVolts - minVolts)
    result.value = Math.min(100, (int) (pct * 100))
    result.descriptionText = "${linkText} battery was ${result.value}%"

	return result
}

private getTemperature(value) {
	def celcius = Integer.parseInt(value, 16).shortValue() / 100
	if(getTemperatureScale() == "C"){
		return celcius
	} else {
		return celsiusToFahrenheit(celcius) as Integer
	}
}

private Map getTemperatureResult(value) {
	def linkText = getLinkText(device)
	if (tempOffset) {
		def offset = tempOffset as int
		def v = value as int
		value = v + offset
	}
	def descriptionText = "${linkText} was ${value}°${temperatureScale}"
    
	return [ name: "temperature", value: value, descriptionText: descriptionText ]
}

//------Command handlers------//
private handleCodeInputs(message) {
    // 8.3.2.4.1
	def keycode = message.data[1] > 0 ? new String(message.data[2..-2] as byte[], 'UTF-8') : "" // 8.3.2.4.1.3
	def reqArmMode = message.data[0] // 8.3.2.4.1.2

    log.debug "Received command with keycode/armMode: ${keycode.inspect()}/${reqArmMode.inspect()}"

	def results = createCodeEntryEvent(keycode, reqArmMode)
	//log.trace "CodeInputs: $results"
	
    return results
}

// Used by SHM Delay to disable logging of invalid pins since the app tracks user pins
def disableInvalidPinLogging(disable) {
    if (disable) {
        log.debug "Disabling invalid user pin logging"
        state.disableInvalidPinLogEntry = true
    } else {
        log.debug "Enabling invalid user pin logging"
        state.disableInvalidPinLogEntry = false
    }
}

private createCodeEntryEvent(keycode, armMode) {
    def results = []
    def map = null
    
    if (device.currentValue("codeunlock") == "disabled") {
        log.warn "Keypad disabled, not processing code entry $keycode"
        map = [ name: "invalidCode", value: "detected", descriptionText: "${armMode ? "Lock" : "Unlock"} code ${keycode ?: ""} entered while keypad was disabled", isStateChange: true, displayed: true ]
    } else {    
        // Legacy handler
        sendEvent(name: "codeEntered", value: ((keycode ?: "0000") + '/' + (armMode as String)), isStateChange: true, displayed: false) // Fix for iL02_1 not reporting code for arming

        // Lock handler
        def codeID = findUserID(keycode)
        def changeType, lockCodes, codeName
        def deviceName = device.displayName
        lockCodes = loadLockCodes()
        if (codeID != null) {
            map = [ name: "lock", value: (armMode ? "locked" : "unlocked"), isStateChange: true, displayed: true ] // Each time a valid code is entered activate the actions (unlike a regular lock)
            codeName = getCodeName(lockCodes, codeID)
            map.descriptionText = "${armMode ? "Locked" : "Unlocked"} by \"$codeName\""
            map.data = [ codeId: codeID as String, usedCode: codeID, codeName: codeName, method: "keypad", armMode: armModeMap[armMode as String] ]
            log.info "Keypad $map.value by $codeName in slot $codeID"
            sendValidKeycodeResponse() // Acknowledge the valid code entry
            sendHubCommand(setModeHelper(armModeMap[armMode as String], 0)) // Since we have a valid code lets update the keypad state
            if (!armMode) {
                autoRelock() // Auto relock if required
            }
        } else if (!keycode) { // iL02_1 does not generate codes while arming
            map = [ name: "lock", value: (armMode ? "locked" : "unlocked"), isStateChange: true, displayed: true ] // Each time the mode is changed activate the actions (unlike a regular lock)
            map.descriptionText = "${armMode ? "Locked" : "Unlocked"}"
            map.data = [ method: "keypad", armMode: armModeMap[armMode as String] ]
            log.info "Keypad $map.value"
            sendValidKeycodeResponse() // Acknowledge the valid code entry
            if (lockCodes) { // If we have any codes programed then change the status otherwise we're using legacy apps
                sendHubCommand(setModeHelper(armModeMap[armMode as String], 0)) // Required for SmartLocks for iL02_1, status needs to be changed otherwise it can't be disarmed
            }
            if (!armMode) {
                autoRelock() // Auto relock if required
            }
        } else {
            map = [ name: "invalidCode", value: "detected", descriptionText: "Invalid ${armMode ? "lock" : "unlock"} code ${keycode ?: ""} entered", isStateChange: true, displayed: state.disableInvalidPinLogEntry ? false : true ]
            log.warn "Invalid code $keycode detected trying to ${armMode ? "lock" : "unlock"} keypad"
            sendInvalidKeycodeResponse() // Send invalid key code
        }
    }
    
    results << createEvent(map)
}



// hexStatus 8.3.2.5.5.2: XXYY <XX - status><YY - seconds>
// 00 (Panel disamed, ready to arm) - Disarmed, green LED (IL02 RED OFF LED, cannot repeat command, seconds -> 0 OFF LED on for 3 seconds, 1+ x10ms flashes purple IRIS light)
// 01 (Armed stay) - Armed partial (UEI -> Red LED, armed stay) (IL02 RED Partial LED, cannot repeat command, seconds -> x10ms flashes purple IRIS light and RED Partial LED)
// 02 (Armed night) - Armed partial (UEI -> Red LED, armed night) (IL02 RED Partial LED, cannot repeat command, seconds -> x10ms flashes purple IRIS light and RED Partial LED)
// 03 (Armed away) - Armed Away (UEI -> Red LED, armed away) (IL02 RED ON LED, cannot repeat command, seconds -> x10ms flashes purple IRIS light and RED ON LED)
// 04 (Exit delay) - (UEI -> Slow beep, 1 per 3 seconds, ignore seconds) (IL02 ignores)
// 05 (Entry delay) - Fast beep (1 per second) (UEI -> Fast beep, 1 per second, ignores seconds) (IL02 cannot repeat same command successively, activates motion, flashes active status LED, seconds: 0 -> ignores/off, 1 -> 2 beeps/sec total 10, 2+ -> 1 beep/sec total 7)
// 05 (Entry delay) - Entry delay (Uses seconds) Appears to keep the status lights as it was
// 06 (Not ready to arm) - Amber status blink (Ignores seconds) (IL02 ignores)
// 07 (In alarm) - UEI -> Red status LED (Ignores seconds) (IL02 Sets off Panic Alarm, all lights on)
// 08 (Arming stay) - Red status blink (UEI -> Red armed stay) (IL02 Partial LED blink, activates motion cannot repeat same command successively, seconds: 0 -> 2 beeps/sec total 13, 1+ -> 1 beep/sec total 7)
// 09 (Arming night) - (UEI -> Red armed night) (IL02 Partial LED blink, activates motion cannot repeat same command successively, seconds: 0 -> 2 beeps/sec total 13, 1+ -> 1 beep/sec total 7)
// 0A (Arming away) - Exit delay Slow beep (2 per second, accelerating to 1 beep per second for the last 10 seconds) - With red flashing status - Uses seconds (UEI -> Red armed away, beeping slowly, ignores seconds)  (IL02 ON LED blink, activates motion cannot repeat same command successively, seconds: 0 -> 2 beeps/sec total 13, 1+ -> 1 beep/sec total 7)
private sendRawStatus(status, seconds = 00, response = false, alarm = false) {
	//status = 0
    //seconds = 0
    
    def hexStatus = zigbee.convertToHexString(status, 2)
    def hexSeconds = zigbee.convertToHexString(seconds, 2)
    def hexAudioState = response ? "00" : (alarm ? "01" : "") // Respond to state change silently, for alarm indicate state otherwise use default
    def hexAudioAlarm = alarm ? "01" : (response ? "00" : "") // Activate alarm (Burglar)
	log.trace "Sending Status ${hexStatus}${hexSeconds}${hexAudioState}${hexAudioAlarm} to device, Response mode: $response, Alarm mode: $alarm"
    
    // Seems to require frame control 9, which indicates a "Server to client" cluster specific command (which seems backward? I thought the keypad was the server)
    /*
    	09 -> Frame Control Field (value indicates cluster specific command with Server to client direction)
		01 -> Transaction sequence number (technically should be different each time but often hardcoded in the DTH).
		04 or 05 -> Command Panel Status Changed 8.3.2.5.5 or Command Get Panel Status Response 8.3.2.5.6
		XX -> Panel Status 8.3.2.5.5.2
		YY -> Seconds Remaining 8.3.2.5.5.5 (when XX is 04 and 05 otherwise 00)
		AA -> Audible Notification 8.3.2.5.5.3 (00 mute, 01 default sound) (used for Response)
		BB -> Alarm Status 8.3.2.5.5.4 (used for Response and Alarm)
	*/
    def cmds = [
        			"raw 0x501 {09 01 ${response ? "05" : "04"} ${hexStatus}${hexSeconds}${hexAudioState}${hexAudioAlarm}}",
        			"send 0x${device.deviceNetworkId} ${device.endpointId as int} 1",
        			"delay 100"
    			]
    
    def results = cmds?.collect { new physicalgraph.device.HubAction(it) }
    return results
}

private getArmModeMap() {
    [
        "0": "disarmed",
        "1": "armedStay",
        "2": "armedNight",
        "3": "armedAway",
        //"${PANEL_STATUS_EXIT_DELAY}": "exitDelay",
        //"${PANEL_STATUS_ENTRY_DELAY}": "entryDelay",
    ]
}

private getReverseArmModeMap() {
    [
        "disarmed": 0,
        "armedStay": 1,
        "armedNight": 2,
        "armedAway": 3,
        //"exitDelay": PANEL_STATUS_EXIT_DELAY,
        //"entryDelay": PANEL_STATUS_ENTRY_DELAY,
    ]
}

// The keypad seems to be expecting responses that are not in-line with the HA 1.2 spec. Maybe HA 1.3 or Zigbee 3.0 ?
def sendStatusToDevice(response = false) { // We can send an update or a response to request
	def armMode = device.currentValue("armMode") ?: "disarmed" // null or empty are disarmed
	log.debug "Sending status to device, Arm mode: $armMode, Response mode: $response"
    
	def status = reverseArmModeMap[armMode]
    if (status == null) {
        log.error "Unknown armMode: $armMode"
    }
	
	// If we're not in one of the 4 basic modes, don't update the status, don't want to override beep timings, exit delay is dependent on it being correct
    if (status != null) {
		return sendRawStatus(status, 0, response)
	} else {
    	return []
    }
}
def notifyPanelStatusChanged(status) {
	//TODO: not yet implemented. May not be needed.
}

def setDisarmed() { setModeHelper("disarmed", 0) }
def setArmedAway(def delay=0) { setModeHelper("armedAway", delay) }
def setArmedStay(def delay=0) { setModeHelper("armedStay", delay) }
def setArmedNight(def delay=0) { setModeHelper("armedNight", delay) }

def setEntryDelay(delay) {
	setModeHelper("entryDelay", delay)
	sendRawStatus(PANEL_STATUS_ENTRY_DELAY, delay) // Entry delay beeps
}

def setExitDelay(delay) {
	setModeHelper("exitDelay", delay)
	sendRawStatus(PANEL_STATUS_EXIT_DELAY, delay)  // Exit delay
}

private setModeHelper(armMode, delay) {
	log.trace "Method setModeHelper mode: $armMode, delay: $delay"
	sendEvent([name: "armMode", value: armMode, data: [delay: delay as int], isStateChange: true])
    if (armMode == "disarmed") { // Clear alarm if active when keypad is explicitly disarmed since it turns off the alarm anyways
        off()
    }
    if (armMode != 'entryDelay') {
        def lastUpdate = formatLocalTime(now())
        sendEvent(name: "lastUpdate", value: lastUpdate, displayed: false)
    }
    sendStatusToDevice()
}

// Acknowledge that a valid pin was entered
private sendValidKeycodeResponse() {
    // Always use 0 since sometimes it doesn't respond to mode 3 (armMode) for UEI
    acknowledgeArmRequest(0)
}

// Sends a high beep to show good entry
def acknowledgeArmRequest(armMode){
    /*
    	09 -> Frame Control Field (value indicates cluster specific command with Server to client direction)
		01 -> Transaction sequence number (technically should be different each time but often hardcoded in the DTH).
        00 -> Command Arm response 8.3.2.5.1
        0x -> Arm Notification Field 8.3.2.5.1.2
    */
    def cmds = [
                    "raw 0x501 {09 01 00 0${armMode}}",
                    "delay 100",
                    "send 0x${device.deviceNetworkId} ${device.endpointId as int} 1",
                    "delay 100"
    			]
	log.debug "Sending acknowledgeArmRequest($armMode)"
    cmds?.each { sendHubCommand(new physicalgraph.device.HubAction(it)) }
    //runIn(3, sendStatusToDevice) // Give it time to update the system
    return null
}

// Send a low beep to show invalid entry
def sendInvalidKeycodeResponse(){
    /*
    	09 -> Frame Control Field (value indicates cluster specific command with Server to client direction)
		01 -> Transaction sequence number (technically should be different each time but often hardcoded in the DTH).
        00 -> Command Arm response 8.3.2.5.1
        04 -> Invalid Arm/Disarm Code
    */
	def cmds = [
        			"raw 0x501 {09 01 00 04}",
                    "delay 100",
        			"send 0x${device.deviceNetworkId} ${device.endpointId as int} 1",
                    "delay 100"
				]
				 
	log.debug "Sending sendInvalidKeycodeResponse"
    cmds?.each { sendHubCommand(new physicalgraph.device.HubAction(it)) }
    //runIn(3, sendStatusToDevice) // Give it time to update the system
    return null
}

def beep(def beepLen = beepLength) {
    beepLen = beepLen ?: defaultBeepLength // take care of null's
	
    def len = zigbee.convertToHexString(beepLen, 2)
    /*
    	09 -> Frame Control Field (value indicates cluster specific command with Server to client direction)
		01 -> Transaction sequence number (technically should be different each time but often hardcoded in the DTH).
		04 -> Command Panel Status Changed Command 8.3.2.5
		05 -> Entry Delay 8.3.2.5.5.2
		YY -> Seconds Remaining 8.3.2.5.5.5
	*/
    def cmds = [
        			"raw 0x501 {09 01 04 05${len}}", // Fast beep (1 per second)
        			"delay 200",
			        "send 0x${device.deviceNetworkId} ${device.endpointId as int} 1",
			        "delay 500"
    			]

    // These devices require and explicit turn off as they don't obey the seconds
    // iMagic requires a separate reset after a delay otherwise it won't trigger again
    // UEI requires a separate turn off otherwise it continues indefinitely
    if (["iMagic by GreatStar", "Technicolor", "Universal Electronics Inc"].any { getDataValue("manufacturer") == it }) {
        log.trace "IL201/UEI keypad detected, turning off beep in $beepLen seconds"
        runIn(beepLen - 1 ?: 1, turnOffBeep)
    }
    
	cmds?.each { sendHubCommand(new physicalgraph.device.HubAction(it)) }

	log.debug "Sending beeps: $beepLen"

    return null
}

def turnOffBeep() {
    def cmds 
    if (["Technicolor", "Universal Electronics Inc"].any { getDataValue("manufacturer") == it }) { // UEI doesn't respond to Entry Delay turn off and requires an arm status
        def armMode = device.currentValue("armMode") ?: "disarmed" // null or empty are disarmed
        def status = reverseArmModeMap[armMode]
        cmds = sendRawStatus(status ?: 0) // Send current arm status or disarmed if status not valid
    } else { // Turn off Entry Delay or it won't trigger again
        /*
            09 -> Frame Control Field (value indicates cluster specific command with Server to client direction)
            01 -> Transaction sequence number (technically should be different each time but often hardcoded in the DTH).
            04 -> Command Panel Status Changed Command 8.3.2.5
            05 -> Entry Delay 8.3.2.5.5.2
            00 -> 0 Seconds Remaining 8.3.2.5.5.5
        */
        cmds = [
            "delay 100", // Some delay so it beeps atleast once
            "raw 0x501 {09 01 04 0500}",
            "send 0x${device.deviceNetworkId} ${device.endpointId as int} 1",
            "delay 500",
        ].collect { new physicalgraph.device.HubAction(it) }
    }
    
	log.debug "Turning off beeps"	
	cmds?.each { sendHubCommand(it) }
    return null
}

// Utility methods
private String swapEndianHex(String hex) {
	reverseArray(hex.decodeHex()).encodeHex()
}

private byte[] reverseArray(byte[] array) {
	int i = 0
	int j = array.length - 1
	byte tmp
	while (j > i) {
		tmp = array[j]
		array[j] = array[i]
		array[i] = tmp
		j--
		i++
	}
	return array
}

// TESTING
private testCmd(){
	//log.trace zigbee.parse('catchall: 0104 0501 01 01 0140 00 4F2D 01 00 0000 07 00 ')
	//beep(10)
	//test exit delay
	//log.debug device.zigbeeId
	//testingTesting()
	//discoverCmds()
	//zigbee.configureReporting(1,0x20,0x20,3600,43200,0x01)		//battery reporting
	//["raw 0x0001 {00 00 06 00 2000 20 100E FEFF 01}",
	//"send 0x${device.deviceNetworkId} ${device.endpointId as int} 1"]
	//zigbee.command(0x0003, 0x00, "0500") //Identify: blinks connection light
    
	//log.debug 		//temperature reporting  
    
	return zigbee.readAttribute(0x0020,0x01) + 
		    zigbee.readAttribute(0x0020,0x02) +
		    zigbee.readAttribute(0x0020,0x03)
}

private discoverCmds(){
    /*
    	Table 2-3
    	08 - standard cluster commands, 0CFFFF manufacturer specific commands
        01 - Transaction ID (fixed)
        11 - Discover Commands Received (Response 8.3.2.4), 13 - Discover Commands Generated (Response 8.3.2.5)
        00FF - Starting at first command (00), upto 255 commands (FF)
	*/
    
	List cmds = ["raw 0x0501 {08 01 11 00FF}", 'delay 200', 
				 "send 0x${device.deviceNetworkId} ${device.endpointId as int} 1", 'delay 500']
	cmds
}

private testingTesting() {
	log.debug "Delay: ${device.currentState("armMode")?.toString()}"
    def cmds = [ 
        			"raw 0x501 {09 01 04 050A}",
                	"delay 200",
					"send 0x${device.deviceNetworkId} ${device.endpointId as int} 1",
                	"delay 500"
    			]
	return cmds
}

// THIS IS THE END OF THE FILE